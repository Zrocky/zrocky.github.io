<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Objective-C Coding Guideline</title>
  <meta name="description" content="Objective-C编码规范，内容来自苹果、谷歌的文档翻译，自己的编码经验和对其它资料的总结。">
  <meta name="author" content="Zrocky">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Objective-C Coding Guideline">
  <meta name="twitter:description" content="Objective-C编码规范，内容来自苹果、谷歌的文档翻译，自己的编码经验和对其它资料的总结。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="Objective-C Coding Guideline">
  <meta property="og:description" content="Objective-C编码规范，内容来自苹果、谷歌的文档翻译，自己的编码经验和对其它资料的总结。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://zrocky.com/2016/04/objectivec-coding-guideline/">
  <link rel="alternate" type="application/rss+xml" title="Zrocky" href="http://zrocky.com/feed.xml">
  
  <!-- <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" /> -->
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Zrocky 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Zrocky logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Zrocky" class="blog-button">Zrocky</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">Stay Hungry, Stay Foolish</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Think Different</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description">欢迎与我交流</p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="/categories" target="_blank" title="categories">分类</a></li>
                
                  <li class="navigation__item"><a href="/archives" target="_blank" title="archives">归档</a></li>
                
                  <li class="navigation__item"><a href="/about" target="_blank" title="about">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/zrocky" title="@zrocky 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:roam@zrocky.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-disabled"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-04-28 02:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2016-04-28</time> &#8226; <span class="post-meta__tags tags">iOS</span>
    </div>
    <h1 class="post-title">Objective-C Coding Guideline</h1>
  </header>

  <section class="post">
    <p>Objective-C编码规范，内容来自苹果、谷歌的文档翻译，自己的编码经验和对其它资料的总结。</p>

<ul>
  <li><a href="https://github.com/Zrocky/iOS-Coding-Guideline">Github</a></li>
</ul>

<h2 id="概要">概要</h2>
<p>Objective-C是一门面向对象的动态编程语言，主要用于编写iOS和Mac应用程序。关于Objective-C的编码规范，苹果和谷歌都已经有很好的总结：</p>

<ul>
  <li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Apple Coding Guidelines for Cocoa</a></li>
  <li><a href="https://google-styleguide.googlecode.com/svn/trunk/objcguide.xml?showone=Line_Length#Line_Length">Google Objective-C Style Guide</a></li>
</ul>

<p>这里整合的代码规范主要总结了以上两文, 加上本人在工作中的总结和经验, 整理出适合我们公司的代码规范.</p>

<h2 id="代码格式">代码格式</h2>

<h3 id="函数的书写">函数的书写</h3>

<p>一个典型的Objective-C函数应该是这样的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp {
    ...    
}
</code></pre></div>
<p>在<code class="highlighter-rouge">-</code>和<code class="highlighter-rouge">(void)</code>之间应该有一个空格，第一个大括号<code class="highlighter-rouge">{</code>的位置在函数所在行的末尾，同样应该有一个空格。</p>

<p>如果一个函数有特别多的参数或者名称很长，应该将其按照<code class="highlighter-rouge">:</code>来对齐分行显示：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-(id)initWithModel:(IPCModle)model
       ConnectType:(IPCConnectType)connectType
        Resolution:(IPCResolution)resolution
          AuthName:(NSString *)authName
          Password:(NSString *)password
               MAC:(NSString *)mac
              AzIp:(NSString *)az_ip
             AzDns:(NSString *)az_dns
             Token:(NSString *)token
             Email:(NSString *)email
          Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate;
</code></pre></div>

<p>在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)short:(GTMFoo *)theFoo
        longKeyword:(NSRect)theRect
  evenLongerKeyword:(float)theInterval
              error:(NSError **)theError {
    ...
}
</code></pre></div>

<h3 id="函数的调用">函数的调用</h3>

<p>函数调用的格式和书写差不多，可以按照函数的长短来选择写在一行或者分成多行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//写在一行
[myObject doFooWith:arg1 name:arg2 error:arg3];

//分行写，按照':'对齐
[myObject doFooWith:arg1
               name:arg2
              error:arg3];

//第一段名称过短的话后续可以进行缩进
[myObj short:arg1
          longKeyword:arg2
    evenLongerKeyword:arg3
                error:arg4];
</code></pre></div>

<p>以下写法是错误的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//错误，要么写在一行，要么全部分行
[myObject doFooWith:arg1 name:arg2
              error:arg3];
[myObject doFooWith:arg1
               name:arg2 error:arg3];

//错误，按照':'来对齐，而不是关键字
[myObject doFooWith:arg1
          name:arg2
          error:arg3];
</code></pre></div>

<h3 id="public和private标记符">@public和@private标记符</h3>

<p>@public和@private标记符应该以<strong>一个空格</strong>来进行缩进：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">MyClass</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="p">{</span>
 <span class="k">@public</span>
  <span class="p">...</span>
 <span class="k">@private</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div>

<h3 id="协议protocols">协议（Protocols）</h3>

<p>在书写协议的时候注意用<code class="highlighter-rouge">&lt;&gt;</code>括起来的协议和类型名之间是没有空格的，比如<code class="highlighter-rouge">IPCConnectHandler()&lt;IPCPreconnectorDelegate&gt;</code>,这个规则适用所有书写协议的地方，包括函数声明、类声明、实例变量等等：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">MyProtocoledClass</span> <span class="p">:</span> <span class="nc">NSObject</span><span class="o">&lt;</span><span class="n">NSWindowDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">@private</span>
    <span class="n">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span> <span class="n">_delegate</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setDelegate</span><span class="o">:</span><span class="p">(</span><span class="n">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="n">aDelegate</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div>

<h3 id="闭包blocks">闭包（Blocks）</h3>

<p>根据block的长度，有不同的书写规则：</p>

<ul>
  <li>较短的block可以写在一行内。</li>
  <li>如果分行显示的话，block的右括号<code class="highlighter-rouge">}</code>应该和调用block那行代码的第一个非空字符对齐。</li>
  <li>block内的代码采用<strong>4个空格</strong>的缩进。</li>
  <li>如果block过于庞大，应该单独声明成一个变量来使用。</li>
  <li><code class="highlighter-rouge">^</code>和<code class="highlighter-rouge">(</code>之间，<code class="highlighter-rouge">^</code>和<code class="highlighter-rouge">{</code>之间都没有空格，参数列表的右括号<code class="highlighter-rouge">)</code>和<code class="highlighter-rouge">{</code>之间有一个空格。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>//较短的block写在一行内
[operation setCompletionBlock:^{ [self onOperationDone]; }];

//分行书写的block，内部使用4空格缩进
[operation setCompletionBlock:^{
    [self.delegate newDataAvailable];
}];
</code></pre></div>

<h3 id="数据结构的语法糖">数据结构的语法糖</h3>

<p>应该使用可读性更好的语法糖来构造<code class="highlighter-rouge">NSArray</code>，<code class="highlighter-rouge">NSDictionary</code>等数据结构，避免使用冗长的<code class="highlighter-rouge">alloc</code>,<code class="highlighter-rouge">init</code>方法。</p>

<p>如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，在语法糖的"[]"或者"{}"两端留有空格
NSArray *array = @[ [foo description], @"Another String", [bar description] ];
NSDictionary *dict = @{ NSForegroundColorAttributeName : [NSColor redColor] };

//不正确，不留有空格降低了可读性
NSArray* array = @[[foo description], [bar description]];
NSDictionary* dict = @{NSForegroundColorAttributeName: [NSColor redColor]};
</code></pre></div>
<p>构造字典时，字典的Key和Value与中间的冒号<code class="highlighter-rouge">:</code>都要留有一个空格</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，冒号':'前后留有一个空格
NSDictionary *option1 = @{
  NSFontAttributeName : [NSFont fontWithName:@"Helvetica-Bold" size:12],
  NSForegroundColorAttributeName : fontColor
};

//错误，冒号前应该有一个空格
NSDictionary *wrong = @{
  AKey:       @"b",
  BLongerKey: @"c",
};

//错误，每一个元素要么单独成为一行，要么全部写在一行内
NSDictionary *alsoWrong= @{ AKey : @"a",
                            BLongerKey : @"b" };
</code></pre></div>

<h2 id="命名规范">命名规范</h2>

<h3 id="基本原则">基本原则</h3>

<h4 id="清晰">清晰</h4>

<p>命名应该尽可能的清晰和简洁，但在Objective-C中，清晰比简洁更重要。由于Xcode强大的自动补全功能，我们不必担心名称过长的问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//清晰
insertObject:atIndex:

//不清晰，insert的对象类型和at的位置属性没有说明
insert:at:

//清晰
removeObjectAtIndex:

//不清晰，remove的对象类型没有说明，参数的作用没有说明
remove:
</code></pre></div>

<p>不要使用单词的简写，拼写出完整的单词：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//清晰
destinationSelection
setBackgroundColor:

//不清晰，不要使用简写
destSel
setBkgdColor:
</code></pre></div>

<p>然而，有部分单词简写在Objective-C编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用，下面列举了部分：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>alloc   == Allocate					max    == Maximum
alt     == Alternate				min    == Minimum
app     == Application				msg    == Message
calc    == Calculate				nib    == Interface Builder archive
dealloc == Deallocate				pboard == Pasteboard
func    == Function					rect   == Rectangle
horiz   == Horizontal				Rep    == Representation (used in class name such as NSBitmapImageRep).
info    == Information				temp   == Temporary
init    == Initialize				vert   == Vertical
int     == Integer
</code></pre></div>

<p>命名方法或者函数时要避免歧义</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//有歧义，是返回sendPort还是send一个Port？
sendPort

//有歧义，是返回一个名字属性的值还是display一个name的动作？
displayName
</code></pre></div>

<h4 id="一致性">一致性</h4>

<p>整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用<code class="highlighter-rouge">count</code>来返回集合的个数，不能在A类中使用<code class="highlighter-rouge">count</code>而在B类中使用<code class="highlighter-rouge">getNumber</code>。</p>

<h3 id="使用前缀">使用前缀</h3>

<p>如果代码需要打包成Framework给别的工程使用，或者工程项目非常庞大，需要拆分成不同的模块，使用命名前缀是非常有用的。</p>

<ul>
  <li>
    <p>前缀由大写的字母缩写组成，比如Cocoa中<code class="highlighter-rouge">NS</code>前缀代表Founation框架中的类，<code class="highlighter-rouge">IB</code>则代表Interface Builder框架。</p>
  </li>
  <li>
    <p>可以在为类、协议、函数、常量以及typedef宏命名的时候使用前缀，但注意<strong>不要</strong>为成员变量或者方法使用前缀，因为他们本身就包含在类的命名空间内。</p>
  </li>
  <li>
    <p>命名前缀的时候不要和苹果SDK框架冲突。</p>
  </li>
</ul>

<h3 id="命名类和协议classprotocol">命名类和协议（Class&amp;Protocol）</h3>

<p>类名以大写字母开头，应该包含一个<em>名词</em>来表示它代表的对象类型，同时可以加上必要的前缀，比如<code class="highlighter-rouge">NSString</code>, <code class="highlighter-rouge">NSDate</code>, <code class="highlighter-rouge">NSScanner</code>, <code class="highlighter-rouge">NSApplication</code>等等。</p>

<p>而协议名称应该清晰地表示它所执行的行为，而且要和类名区别开来，所以通常使用<code class="highlighter-rouge">ing</code>词尾来命名一个协议，比如<code class="highlighter-rouge">NSCopying</code>,<code class="highlighter-rouge">NSLocking</code>。</p>

<p>有些协议本身包含了很多不相关的功能，主要用来为某一特定类服务，这时候可以直接用类名来命名这个协议，比如<code class="highlighter-rouge">NSObject</code>协议，它包含了id对象在生存周期内的一系列方法。</p>

<h3 id="命名头文件headers">命名头文件（Headers）</h3>

<p>源码的头文件名应该清晰地暗示它的功能和包含的内容：</p>

<ul>
  <li>
    <p>如果头文件内只定义了单个类或者协议，直接用类名或者协议名来命名头文件，比如<code class="highlighter-rouge">NSLocale.h</code>定义了<code class="highlighter-rouge">NSLocale</code>类。</p>
  </li>
  <li>
    <p>如果头文件内定义了一系列的类、协议、类别，使用其中最主要的类名来命名头文件，比如<code class="highlighter-rouge">NSString.h</code>定义了<code class="highlighter-rouge">NSString</code>和<code class="highlighter-rouge">NSMutableString</code>。</p>
  </li>
  <li>
    <p>每一个Framework都应该有一个和框架同名的头文件，包含了框架中所有公共类头文件的引用，比如<code class="highlighter-rouge">Foundation.h</code></p>
  </li>
  <li>
    <p>Framework中有时候会实现在别的框架中类的类别扩展，这样的文件通常使用<code class="highlighter-rouge">被扩展的框架名</code>+<code class="highlighter-rouge">Additions</code>的方式来命名，比如<code class="highlighter-rouge">NSBundleAdditions.h</code>。</p>
  </li>
</ul>

<h3 id="命名方法methods">命名方法（Methods）</h3>

<p>Objective-C的方法名通常都比较长，这是为了让程序有更好地可读性，按苹果的说法<em>“好的方法名应当可以以一个句子的形式朗读出来”</em>。</p>

<p>方法一般以小写字母打头，每一个后续的单词首字母大写，方法名中不应该有标点符号（<em>包括下划线</em>），有两个例外：</p>

<ul>
  <li>可以用一些通用的大写字母缩写打头方法，比如<code class="highlighter-rouge">PDF</code>,<code class="highlighter-rouge">TIFF</code>等。</li>
  <li>可以用带下划线的前缀来命名私有方法或者类别中的方法。</li>
</ul>

<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code class="highlighter-rouge">do</code>，<code class="highlighter-rouge">does</code>这种多余的关键字，动词本身的暗示就足够了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//动词打头的方法表示让对象执行一个动作
- (void)invokeWithTarget:(id)target;
- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem;
</code></pre></div>

<p>如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加<code class="highlighter-rouge">get</code>或者其他的动词前缀：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，使用属性名来命名方法
- (NSSize)cellSize;

//错误，添加了多余的动词前缀
- (NSSize)calcCellSize;
- (NSSize)getCellSize;
</code></pre></div>

<p>对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，保证每个参数都有关键词修饰
- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;

//错误，遗漏关键词
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;

//正确
- (id)viewWithTag:(NSInteger)aTag;

//错误，关键词的作用不清晰
- (id)taggedView:(int)aTag;
</code></pre></div>

<p>不要用<code class="highlighter-rouge">and</code>来连接两个参数，通常<code class="highlighter-rouge">and</code>用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候应该拆分成两个独立的方法</em>）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//错误，不要使用"and"来连接参数
- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;

//正确，使用"and"来表示两个相对独立的操作
- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;
</code></pre></div>

<p>方法的参数命名也有一些需要注意的地方:</p>
<ul>
  <li>和方法名类似，参数的第一个字母小写，后面的每一个单词首字母大写</li>
  <li>不要再方法名中使用类似<code class="highlighter-rouge">pointer</code>,<code class="highlighter-rouge">ptr</code>这样的字眼去表示指针，参数本身的类型足以说明</li>
  <li>不要使用只有一两个字母的参数名</li>
  <li>不要使用简写，拼出完整的单词</li>
</ul>

<p>下面列举了一些常用参数名：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...action:(SEL)aSelector
...alignment:(int)mode
...atIndex:(int)index
...content:(NSRect)aRect
...doubleValue:(double)aDouble
...floatValue:(float)aFloat
...font:(NSFont *)fontObj
...frame:(NSRect)frameRect
...intValue:(int)anInt
...keyEquivalent:(NSString *)charCode
...length:(int)numBytes
...point:(NSPoint)aPoint
...stringValue:(NSString *)aString
...tag:(int)anInt
...target:(id)anObject
...title:(NSString *)aString
</code></pre></div>

<h3 id="存取方法accessor-methods">存取方法（Accessor Methods）</h3>

<p>存取方法是指用来获取和设置类属性值的方法，属性的不同类型，对应着不同的存取方法规范：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//属性是一个名词时的存取方法范式
- (type)noun;
- (void)setNoun:(type)aNoun;
//栗子
- (NSString *)title;
- (void)setTitle:(NSString *)aTitle;

//属性是一个形容词时存取方法的范式
- (BOOL)isAdjective;
- (void)setAdjective:(BOOL)flag;
//栗子
- (BOOL)isEditable;
- (void)setEditable:(BOOL)flag;

//属性是一个动词时存取方法的范式
- (BOOL)verbObject;
- (void)setVerbObject:(BOOL)flag;
//栗子
- (BOOL)showsAlpha;
- (void)setShowsAlpha:(BOOL)flag;
</code></pre></div>

<p>命名存取方法时不要将动词转化为被动形式来使用：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确
- (void)setAcceptsGlyphInfo:(BOOL)flag;
- (BOOL)acceptsGlyphInfo;

//错误，不要使用动词的被动形式
- (void)setGlyphInfoAccepted:(BOOL)flag;
- (BOOL)glyphInfoAccepted;
</code></pre></div>

<p>可以使用<code class="highlighter-rouge">can</code>,<code class="highlighter-rouge">should</code>,<code class="highlighter-rouge">will</code>等词来协助表达存取方法的意思，但不要使用<code class="highlighter-rouge">do</code>,和<code class="highlighter-rouge">does</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确
- (void)setCanHide:(BOOL)flag;
- (BOOL)canHide;
- (void)setShouldCloseDocument:(BOOL)flag;
- (BOOL)shouldCloseDocument;

//错误，不要使用"do"或者"does"
- (void)setDoesAcceptGlyphInfo:(BOOL)flag;
- (BOOL)doesAcceptGlyphInfo;
</code></pre></div>

<p>为什么Objective-C中不适用<code class="highlighter-rouge">get</code>前缀来表示属性获取方法？因为<code class="highlighter-rouge">get</code>在Objective-C中通常只用来表示从函数指针返回值的函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//三个参数都是作为函数的返回值来使用的，这样的函数名可以使用"get"前缀
- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;
</code></pre></div>

<h3 id="命名委托delegate">命名委托（Delegate）</h3>

<p>当特定的事件发生时，对象会触发它注册的委托方法。委托是Objective-C中常用的传递消息的方式。委托有它固定的命名范式。</p>

<p>一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为<code class="highlighter-rouge">sender</code>的参数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//第一个关键词为触发委托的类名
- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;

//当只有一个"sender"参数时可以省略类名
- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;
</code></pre></div>

<p>根据委托方法触发的时机和目的，使用<code class="highlighter-rouge">should</code>,<code class="highlighter-rouge">will</code>,<code class="highlighter-rouge">did</code>等关键词</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)browserDidScroll:(NSBrowser *)sender;

- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;、

- (BOOL)windowShouldClose:(id)sender;
</code></pre></div>

<h3 id="集合操作类方法collection-methods">集合操作类方法（Collection Methods）</h3>

<p>有些对象管理着一系列其它对象或者元素的集合，需要使用类似“增删查改”的方法来对集合进行操作，这些方法的命名范式一般为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//集合操作范式
- (void)addElement:(elementType)anObj;
- (void)removeElement:(elementType)anObj;
- (NSArray *)elements;

//栗子
- (void)addLayoutManager:(NSLayoutManager *)obj;
- (void)removeLayoutManager:(NSLayoutManager *)obj;
- (NSArray *)layoutManagers;
</code></pre></div>

<p>注意，如果返回的集合是无序的，使用<code class="highlighter-rouge">NSSet</code>来代替<code class="highlighter-rouge">NSArray</code>。如果需要将元素插入到特定的位置，使用类似于这样的命名：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index;
- (void)removeLayoutManagerAtIndex:(int)index;
</code></pre></div>

<p>如果管理的集合元素中有指向管理对象的指针，要设置成<code class="highlighter-rouge">weak</code>类型以防止引用循环。</p>

<p>下面是SDK中<code class="highlighter-rouge">NSWindow</code>类的集合操作方法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;
- (void)removeChildWindow:(NSWindow *)childWin;
- (NSArray *)childWindows;
- (NSWindow *)parentWindow;
- (void)setParentWindow:(NSWindow *)window;
</code></pre></div>

<h3 id="命名属性和实例变量propertiesinstance-variables">命名属性和实例变量（Properties&amp;Instance Variables）</h3>

<p>属性和对象的存取方法相关联，属性的第一个字母小写，后续单词首字母大写，不必添加前缀。属性按功能命名成名词或者动词：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">//名词属性
</span><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">title</span><span class="p">;</span>

<span class="c1">//动词属性
</span><span class="k">@property</span> <span class="p">(</span><span class="n">assign</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">showsAlpha</span><span class="p">;</span>
</code></pre></div>

<p>属性也可以命名成形容词，这时候通常会指定一个带有<code class="highlighter-rouge">is</code>前缀的get方法来提高可读性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@property</span> <span class="p">(</span><span class="n">assign</span><span class="p">,</span> <span class="n">getter</span><span class="o">=</span><span class="n">isEditable</span><span class="p">)</span> <span class="n">BOOL</span> <span class="n">editable</span><span class="p">;</span>
</code></pre></div>

<p>一般来说，类需要对使用者隐藏数据存储的细节，所以不要将实例方法定义成公共可访问的接口，可以使用<code class="highlighter-rouge">@private</code>，<code class="highlighter-rouge">@protected</code>前缀。</p>

<p><em>按苹果的说法，不建议在除了<code class="highlighter-rouge">init</code>和<code class="highlighter-rouge">dealloc</code>方法以外的地方直接访问实例变量.</em></p>

<h3 id="命名常量constants">命名常量（Constants）</h3>

<p>如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。
建议使用 <code class="highlighter-rouge">NS_ENUM</code> 和 <code class="highlighter-rouge">NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html">Adopting Modern Objective-C</a> 一文：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//定义一个枚举
typedef NS_ENUM(NSInteger, NSMatrixMode) {
    NSRadioModeMatrix,
    NSHighlightModeMatrix,
    NSListModeMatrix,
    NSTrackModeMatrix
};
</code></pre></div>

<p>定义bit map：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typedef NS_OPTIONS(NSUInteger, NSWindowMask) {
    NSBorderlessWindowMask      = 0,
    NSTitledWindowMask          = 1 &lt;&lt; 0,
    NSClosableWindowMask        = 1 &lt;&lt; 1,
    NSMiniaturizableWindowMask  = 1 &lt;&lt; 2,
    NSResizableWindowMask       = 1 &lt;&lt; 3
};
</code></pre></div>

<p>使用<code class="highlighter-rouge">const</code>定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const float NSLightGray;
</code></pre></div>

<p>不要使用<code class="highlighter-rouge">#define</code>宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用<code class="highlighter-rouge">const</code>定义。<code class="highlighter-rouge">#define</code>通常用来给编译器决定是否编译某块代码，比如常用的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#ifdef DEBUG
</code></pre></div>

<p>注意到一般由编译器定义的宏会在前后都有一个<code class="highlighter-rouge">__</code>，比如<em><code class="highlighter-rouge">__MACH__</code></em>。</p>

<h3 id="命名通知notifications">命名通知（Notifications）</h3>

<p>通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，通知的命名范式是：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[触发通知的类名] + [Did | Will] + [动作] + Notification
</code></pre></div>

<p>栗子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>NSApplicationDidBecomeActiveNotification
NSWindowDidMiniaturizeNotification
NSTextViewDidChangeSelectionNotification
NSColorPanelColorDidChangeNotification
</code></pre></div>

<h2 id="注释">注释</h2>

<p>读没有注释代码的痛苦你我都体会过，好的注释不仅能让人轻松读懂你的程序，还能提升代码的逼格。注意注释是为了让别人看懂，而不是仅仅你自己。</p>

<h3 id="代码注释">代码注释</h3>

<p>好的代码应该是“自解释”（self-documenting）的，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。</p>

<p>方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，好处是可以在引用的地方<code class="highlighter-rouge">alt+点击</code>自动弹出注释，非常方便。</p>

<p>有很多可以自动生成注释格式的插件，推荐使用<a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter</a>：</p>

<p><img src="https://raw.github.com/onevcat/VVDocumenter-Xcode/master/ScreenShot.gif" alt="Screenshot" /></p>

<p>一些良好的注释：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 *  Create a new preconnector to replace the old one with given mac address.
 *  NOTICE: We DO NOT stop the old preconnector, so handle it by yourself.
 *
 *  @param type       Connect type the preconnector use.
 *  @param macAddress Preconnector's mac address.
 */</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">refreshConnectorWithConnectType</span><span class="p">:(</span><span class="n">IPCConnectType</span><span class="p">)</span><span class="nv">type</span>  <span class="nf">Mac</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">macAddress</span><span class="p">;</span>

<span class="cm">/**
 *  Stop current preconnecting when application is going to background.
 */</span>
<span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopRunning</span><span class="p">;</span>

<span class="cm">/**
 *  Get the COPY of cloud device with a given mac address.
 *
 *  @param macAddress Mac address of the device.
 *
 *  @return Instance of IPCCloudDevice.
 */</span>
<span class="k">-</span><span class="p">(</span><span class="n">IPCCloudDevice</span> <span class="o">*</span><span class="p">)</span><span class="nf">getCloudDeviceWithMac</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">macAddress</span><span class="p">;</span>

<span class="c1">// A delegate for NSApplication to handle notifications about app
// launch and shutdown. Owned by the main app controller.
</span><span class="k">@interface</span> <span class="nc">MyAppDelegate</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</code></pre></div>

<p>协议、委托的注释要明确说明其被触发的条件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/** Delegate - Sent when failed to init connection, like p2p failed. */
-(void)initConnectionDidFailed:(IPCConnectHandler *)handler;
</code></pre></div>

<p>如果在注释中要引用参数名或者方法函数名，使用<code class="highlighter-rouge">||</code>将参数或者方法括起来以避免歧义：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Sometimes we need |count| to be less than zero.

// Remember to call |StringWithoutSpaces("foo bar baz")|
</code></pre></div>

<p><strong>定义在头文件里的接口方法、属性必须要有注释！</strong></p>

<h2 id="编码风格">编码风格</h2>

<h3 id="不要使用new方法">不要使用new方法</h3>

<p>尽管很多时候能用<code class="highlighter-rouge">new</code>代替<code class="highlighter-rouge">alloc init</code>方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用<code class="highlighter-rouge">alloc init</code>方法，使用<code class="highlighter-rouge">new</code>会让一些人困惑。</p>

<h3 id="引用框架的根头文件">引用框架的根头文件</h3>

<p>上面提到过，每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，引用根头文件
#import &lt;Foundation/Foundation.h&gt;

//错误，不要单独引用框架内的其它头文件
#import &lt;Foundation/NSArray.h&gt;
#import &lt;Foundation/NSString.h&gt;
</code></pre></div>

<h3 id="bool的使用">BOOL的使用</h3>

<p>BOOL在Objective-C中被定义为<code class="highlighter-rouge">signed char</code>类型，这意味着一个BOOL类型的变量不仅仅可以表示<code class="highlighter-rouge">YES</code>(1)和<code class="highlighter-rouge">NO</code>(0)两个值，所以永远<strong>不要</strong>将BOOL类型变量直接和<code class="highlighter-rouge">YES</code>比较：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较
BOOL great = [foo isGreat];
if (great == YES)
  // ...be great!

//正确
BOOL great = [foo isGreat];
if (great)
  // ...be great!
</code></pre></div>

<p>同样的，也不要将其它类型的值作为BOOL来返回，这种情况下，BOOL变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如<code class="highlighter-rouge">&amp;&amp;</code>,<code class="highlighter-rouge">||</code>,<code class="highlighter-rouge">!</code>的返回是可以直接赋给BOOL的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//错误，不要将其它类型转化为BOOL返回
- (BOOL)isBold {
  return [self fontTraits] &amp; NSFontBoldTrait;
}
- (BOOL)isValid {
  return [self stringValue];
}

//正确
- (BOOL)isBold {
  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;
}

//正确，逻辑操作符可以直接转化为BOOL
- (BOOL)isValid {
  return [self stringValue] != nil;
}
- (BOOL)isEnabled {
  return [self isValid] &amp;&amp; [self isBold];
}
</code></pre></div>

<p>另外BOOL类型可以和<code class="highlighter-rouge">_Bool</code>,<code class="highlighter-rouge">bool</code>相互转化，但是<strong>不能</strong>和<code class="highlighter-rouge">Boolean</code>转化。</p>

<h3 id="使用arc">使用ARC</h3>

<p>除非想要兼容一些古董级的机器和操作系统，我们没有理由放弃使用ARC。在最新版的Xcode中，ARC是自动打开的，所以直接使用就好了。</p>

<h3 id="在init和dealloc中不要用存取方法访问实例变量">在init和dealloc中不要用存取方法访问实例变量</h3>

<p>当<code class="highlighter-rouge">init</code><code class="highlighter-rouge">dealloc</code>方法被执行时，类的运行时环境不是处于正常状态的，使用存取方法访问变量可能会导致不可预料的结果，因此应当在这两个方法内直接访问实例变量。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，直接访问实例变量
- (instancetype)init {
  self = [super init];
  if (self) {
    _bar = [[NSMutableString alloc] init];
  }
  return self;
}
- (void)dealloc {
  [_bar release];
  [super dealloc];
}

//错误，不要通过存取方法访问
- (instancetype)init {
  self = [super init];
  if (self) {
    self.bar = [NSMutableString string];
  }
  return self;
}
- (void)dealloc {
  self.bar = nil;
  [super dealloc];
}
</code></pre></div>

<h3 id="按照定义的顺序释放资源">按照定义的顺序释放资源</h3>

<p>在类或者Controller的生命周期结束时，往往需要做一些扫尾工作，比如释放资源，停止线程等，这些扫尾工作的释放顺序应当与它们的初始化或者定义的顺序保持一致。这样做是为了方便调试时寻找错误，也能防止遗漏。</p>

<h3 id="使用nsnumber的语法糖">使用NSNumber的语法糖</h3>

<p>使用带有<code class="highlighter-rouge">@</code>符号的语法糖来生成NSNumber对象能使代码更简洁：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>NSNumber *fortyTwo = @42;
NSNumber *piOverTwo = @(M_PI / 2);
enum {
  kMyEnum = 2;
};
NSNumber *myEnum = @(kMyEnum);
</code></pre></div>

<h3 id="nil检查">nil检查</h3>

<p>因为在Objective-C中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。</p>

<p>另外，不要使用诸如<code class="highlighter-rouge">nil == Object</code>或者<code class="highlighter-rouge">Object == nil</code>的形式来判断。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，直接判断
if (!objc) {
	...	
}

//错误，不要使用nil == Object的形式
if (nil == objc) {
	...	
}
</code></pre></div>

<h3 id="属性的线程安全">属性的线程安全</h3>

<p>定义一个属性时，编译器会自动生成线程安全的存取方法（Atomic），但这样会大大降低性能，特别是对于那些需要频繁存取的属性来说，是极大的浪费。所以如果定义的属性不需要线程保护，记得手动添加属性关键字<code class="highlighter-rouge">nonatomic</code>来取消编译器的优化。</p>

<h3 id="点分语法的使用">点分语法的使用</h3>

<p>不要用点分语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//正确，使用点分语法访问属性
NSString *oldName = myObject.name;
myObject.name = @"Alice";

//错误，不要用点分语法调用方法
NSArray *array = [NSArray arrayWithObject:@"hello"];
NSUInteger numberOfItems = array.count;
array.release;
</code></pre></div>
<h3 id="delegate要使用弱引用">Delegate要使用弱引用</h3>

<p>一个类的Delegate对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/** delegate */</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">weak</span><span class="p">)</span> <span class="n">id</span> <span class="o">&lt;</span><span class="n">IPCConnectHandlerDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
</code></pre></div>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/05/ios-develop-guideline/" title="link to iOS Develop Guideline">iOS Develop Guideline</a></h2>
       <p class="excerpt">本规范因为Xcode版本的更迭，部分内容已经不太适用。本文仅供参考。以下是我们公司在iOS开发前需要了解的开发规范, 总结自日常的开发过程和团队所有的经验.开发工具以下列举了我们公司在iOS开发中经常使用到工具, 并附上地址, 原则上需要全部安装  Xcode 历史版本  RubyGems (Ruby环境)  Alcatraz (Xcode开发工具安装包)以下插件均可在Alcatraz插件安装包中下载安装  Peckham (头文件快捷导入)  cocoapods plugin (coco...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-05-04 02:00:00 +0800" class="post-list__meta--date date">2016-05-04</time> &#8226; <span class="post-list__meta--tags tags">iOS</span><a class="btn-border-small" href=/2016/05/ios-develop-guideline/>继续阅读</a></div>
   </div>
   
   
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://zrocky.com/2016/04/objectivec-coding-guideline/";
        this.page.identifier = "/2016/04/objectivec-coding-guideline/";
    };

    var disqus_shortname = 'Zrocky';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="http://zrocky.com">@Zrocky</a> 创建 - &copy; 2019</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-119024149-1', 'zrocky.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
